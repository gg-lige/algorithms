//package com.lg.sort;
//
///**
// * Created by lg on 2018/3/26.
// */
//public class Sort {
//    private static boolean less(Comparable a, Comparable b) {
//        return a.compareTo(b) < 0;
//    }
//
//    private static void exch(Comparable[] a, int i, int j) {
//        Comparable t = a[i];
//        a[i] = a[j];
//        a[j] = t;
//    }
//
//    //1.快排
//    public static void sort(Comparable[] a) {
//        sort(a, 0, a.length - 1);
//    }
//
//    private static void sort(Comparable[] a, int lo, int hi) {
//        if (hi <= lo) return;
//        int j = partition(a, lo, hi);
//        sort(a, lo, j - 1);
//        sort(a, j + 1, hi);
//    }
//
//    private static int partition(Comparable[] a, int lo, int hi) {
//        int i = lo, j = hi + 1;
//        Comparable v = a[lo];
//        while (true) {
//            while (less(a[++i], v)) if (i == hi) break; //从左到右找第一个>v的
//            while (less(v, a[--j])) if (j == lo) break;  //从右到左第一个<v的
//            if (i >= j) break;
//            exch(a, i, j);
//        }
//        exch(a, lo, j);
//        return j;
//    }
//
//    //1.三向快排
//    public static void sort(Comparable[] a) {
//        sort(a, 0, a.length - 1);
//    }
//
//    private static void sort(Comparable[] a, int lo, int hi) {
//        if (hi <= lo) return;
//        int lt = lo, i = lo + 1, gt = hi;
//        Comparable v = a[lo];
//        while (i <= gt) {
//            int cmp = a[i].compareTo(v);
//            if (cmp < 0) exch(a, lt++, i++);
//            else if (cmp > 0) exch(a, i, gt--);
//            else i++;
//        }
//        sort(a, lo, lt - 1);
//        sort(a, gt + 1, hi);
//
//    }
//
//    //2.归并(递归)
//    private static Comparable[] aux;//归并所需的辅助数组
//
//    public static void sort(Comparable[] a) {
//        aux = new Comparable[a.length];
//        sort(a, 0, a.length - 1);
//    }
//
//    private static void sort(Comparable[] a, int lo, int hi) {
//        if (hi <= lo) return;
//        int mid = lo + (hi - lo) / 2;
//        sort(a, lo, mid);
//        sort(a, mid + 1, hi);
//        merge(a, lo, mid, hi);
//    }
//
//    public static void merge(Comparable[] a, int lo, int mid, int hi) {
//        //归并a[lo..mid],a[mid+1..hi]
//        int i = lo, j = mid + 1;
//        for (int k = lo; k <= hi; k++)
//            aux[k] = a[k];   //a拷贝到aux
//
//        for (int k = lo; k <= hi; k++)
//            if (i > mid) a[k] = aux[j++];
//            else if (j > hi) a[k] = aux[i++];
//            else if (less(aux[i], aux[j])) a[k] = aux[i++];
//            else a[k] = aux[j++];
//    }
//
//    //2.归并（循环）
//    private static Comparable[] aux;//归并所需的辅助数组
//
//    public static void sort(Comparable[] a) {
//        int N = a.length;
//        aux = new Comparable[N];
//        for (int sz = 1; sz < N; sz = sz + sz) //按1，2，4，8，归并
//            for (int lo = 0; lo < N - sz; lo += sz + sz)
//                merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1));
//    }
//
//
//    public static void merge(Comparable[] a, int lo, int mid, int hi) {
//        //归并a[lo..mid],a[mid+1..hi]
//        int i = lo, j = mid + 1;
//        for (int k = lo; k <= hi; k++)
//            aux[k] = a[k];   //a拷贝到aux
//
//        for (int k = lo; k <= hi; k++)
//            if (i > mid) a[k] = aux[j++];
//            else if (j > hi) a[k] = aux[i++];
//            else if (less(aux[i], aux[j])) a[k] = aux[i++];
//            else a[k] = aux[j++];
//    }
//
//    //3.插入
//    public static void sort(Comparable[] a) {
//        int N = a.length;
//        for (int i = 1; i < N; i++) {
//            for (int j = i; j > 0 && less(a[j], a[j - 1]); j--)
//                exch(a, j - 1, j);
//        }
//    }
//
//    //4.希尔排序
//    public static void sort(Comparable[] a) {
//        int N = a.length;
//        int h = 1;
//        while (h < N / 3) h = h * 3 + 1;
//        while (h >= 1) {
//            for (int i = h; i < N; i++) {
//                for (int j = i; j >= h && less(a[j], a[j - h]); j -= h)
//                    exch(a, j - h, j);
//            }
//            h /= 3;
//        }
//    }
//
//    //5.选择排序
//    public static void sort(Comparable[] a) {
//        int N = a.length;
//        for (int i = 0; i < N; i++) {
//            int min = i;
//            for (int j = i + 1; j < N; j++) {
//                if (less(a[j], a[min]))
//                    min = j;
//            }
//            exch(a, i, min);
//        }
//    }
//
//    //6.冒泡
//    public static void sort(Comparable[] a) {
//        int N = a.length;
//        for (int i = 0; i < N; i++) {
//            for (int j = 0; j < N - 1 - i; j++) {
//                if (less(j + 1, j)) exch(a, j + 1, j);
//            }
//        }
//    }
//
//    //6.堆排序
//    public static void sort(Comparable[] a) {//sort与sink函数的a数组的值在1-N之间
//        int N = a.length;
//        for (int k = N / 2; k >= 1; k--)
//            sink(a, k, N);  //调整为最大堆
//        while (N > 1) {
//            exch(a, 1, N--);
//            sink(a, 1, N);
//        }
//    }
//
//    private static void sink(Comparable[] a, int k, int N) {
//        while (2 * k <= N) {
//            int j = 2 * k;
//            if (j < N && less(a, j, j + 1)) j++;
//            if (!less(a, k, j)) break;
//            exch(a, k, j);
//            k = j;
//        }
//    }
//
//    private static boolean less(Comparable[] a, int i, int j) {
//        return a[i - 1].compareTo(a[j - 1]) < 0; //注意less 与exch函数的索引值均-1
//    }
//
//    private static void exch(Comparable[] a, int i, int j) {
//        Comparable t = a[i - 1];
//        a[i - 1] = a[j - 1];
//        a[j - 1] = t;
//    }
//
//    //7. 优先队列实现的堆排序
//    private Key[] pq;
//    private int N = 0;
//
//    public MaxPQ(int max) {
//        pq = (Key[]) new Comparable[max + 1];
//    }
//
//    boolean isEmpty() {
//        return N == 0;
//    }
//
//    public int size() {
//        return N;
//    }
//
//    public void insert(Key v) {
//        pq[++N] = v;
//        swim(N);
//    }
//
//    private void swim(int k) {
//        while (k > 1 && less(k / 2, k)) {
//            exch(k / 2, k);
//            k = k / 2;
//        }
//    }
//
//    public Key delMax() {
//        Key max = pq[1]; //从根结点得到最大元素
//        exch(1, N--); //交换其和最后一个节点
//        pq[N + 1] = null;//防止对象游离
//        sink(1);//恢复堆的有序性
//        return max;
//    }
//
//    private void sink(int k) {
//        while (2 * k <= N) {
//            int j = 2 * k;
//            if (j < N && less(j, j + 1)) j++;
//            if (!less(k, j)) break;
//            exch(k, j);
//            k = j;
//        }
//    }
//
//    private boolean less(int i, int j) {
//        return pq[i].compareTo(pq[j]) < 0;
//    }
//
//    private void exch(int i, int j) {
//        Key t = pq[i];
//        pq[i] = pq[j];
//        pq[j] = t;
//    }
//
//}
